#!/usr/bin/env ruby

# quick_test.rb - Quick validation test for refactoring changes
#
# This script performs a fast validation test to ensure the event_checker.rb
# script still works after refactoring changes. It runs a minimal test case
# and validates basic functionality.
#
# Usage: ruby quick_test.rb

require 'date'
require 'fileutils'
require 'tempfile'

class QuickTester
  def initialize
    @test_dir = "quick_test_#{Time.now.strftime("%Y%m%d_%H%M%S")}"
    @start_date = Date.today
    @end_date = Date.today + 1  # 2-day range for speed
    
    puts "âš¡ Quick Refactoring Validation Test"
    puts "=" * 40
    puts "ğŸ“… Testing date range: #{@start_date} to #{@end_date}"
  end
  
  def run_test
    # Create temporary test directory
    FileUtils.mkdir_p(@test_dir)
    
    begin
      # Backup existing files
      backup_files
      
      # Run the test
      success = run_event_checker
      
      if success
        # Validate outputs
        validate_outputs
      else
        puts "âŒ Event checker execution failed!"
        show_error_log
        return false
      end
      
    ensure
      # Restore original files
      restore_files
      
      # Clean up test directory
      FileUtils.rm_rf(@test_dir) if Dir.exist?(@test_dir)
    end
    
    true
  end
  
  private
  
  def backup_files
    puts "ğŸ’¾ Backing up existing files..."
    
    files_to_backup = ['upcoming.md', 'ongoing.md', 'archive.md']
    
    files_to_backup.each do |file|
      if File.exist?(file)
        backup_path = File.join(@test_dir, "backup_#{file}")
        FileUtils.cp(file, backup_path)
      end
    end
  end
  
  def restore_files
    puts "ğŸ”„ Restoring original files..."
    
    Dir.glob(File.join(@test_dir, "backup_*")).each do |backup_file|
      original_file = File.basename(backup_file).sub('backup_', '')
      FileUtils.cp(backup_file, original_file)
    end
  end
  
  def run_event_checker
    puts "ğŸƒ Running event_checker.rb..."
    
    # Create input file
    input_file = File.join(@test_dir, "input.txt")
    File.write(input_file, "#{@start_date.strftime('%Y-%m-%d')}\n#{@end_date.strftime('%Y-%m-%d')}\n")
    
    # Run with timeout to prevent hanging
    output_file = File.join(@test_dir, "output.txt")
    error_file = File.join(@test_dir, "error.txt")
    
    # Use gtimeout if available (brew install coreutils), otherwise use plain ruby with a reasonable expectation
    timeout_cmd = system("which gtimeout > /dev/null 2>&1") ? "gtimeout 120" : ""
    cmd = "cd #{Dir.pwd} && #{timeout_cmd} ruby event_checker.rb < #{input_file} > #{output_file} 2> #{error_file}"
    
    # Execute and capture result
    result = system(cmd)
    
    if result
      puts "   âœ… Execution completed successfully"
    else
      puts "   âŒ Execution failed or timed out"
    end
    
    result
  end
  
  def validate_outputs
    puts "ğŸ” Validating outputs..."
    
    validations = [
      validate_upcoming_file,
      validate_ongoing_file,
      validate_no_crashes,
      validate_basic_functionality
    ]
    
    if validations.all?
      puts "   âœ… All validations passed!"
      return true
    else
      puts "   âŒ Some validations failed!"
      return false
    end
  end
  
  def validate_upcoming_file
    unless File.exist?('upcoming.md')
      puts "   âŒ upcoming.md not created"
      return false
    end
    
    content = File.read('upcoming.md')
    
    unless content.include?('Upcoming Cultural Events')
      puts "   âŒ upcoming.md missing header"
      return false
    end
    
    unless content.include?('Generated by KrakÃ³w Event Checker')
      puts "   âŒ upcoming.md missing version info"  
      return false
    end
    
    puts "   âœ… upcoming.md looks valid"
    true
  end
  
  def validate_ongoing_file
    unless File.exist?('ongoing.md')
      puts "   âŒ ongoing.md not created"
      return false
    end
    
    content = File.read('ongoing.md')
    
    unless content.include?('Ongoing Cultural Events')
      puts "   âŒ ongoing.md missing header"
      return false
    end
    
    puts "   âœ… ongoing.md looks valid"
    true
  end
  
  def validate_no_crashes
    error_file = File.join(@test_dir, "error.txt")
    
    if File.exist?(error_file) && File.size(error_file) > 0
      error_content = File.read(error_file)
      
      # Check for Ruby errors
      if error_content.match?(/(Error|Exception|undefined method|uninitialized constant)/i)
        puts "   âŒ Ruby errors detected:"
        puts error_content.lines.first(3).map { |line| "      #{line.strip}" }
        return false
      end
    end
    
    puts "   âœ… No crashes detected"
    true
  end
  
  def validate_basic_functionality
    output_file = File.join(@test_dir, "output.txt")
    
    unless File.exist?(output_file)
      puts "   âŒ No output captured"
      return false
    end
    
    output_content = File.read(output_file)
    
    # Check for expected output patterns
    expected_patterns = [
      /KrakÃ³w Event Checker/,
      /Searching for events/,
      /Event check completed/
    ]
    
    missing_patterns = expected_patterns.reject { |pattern| output_content.match?(pattern) }
    
    if missing_patterns.any?
      puts "   âŒ Missing expected output patterns:"
      missing_patterns.each { |pattern| puts "      #{pattern.inspect}" }
      return false
    end
    
    puts "   âœ… Basic functionality working"
    true
  end
  
  def show_error_log
    error_file = File.join(@test_dir, "error.txt")
    output_file = File.join(@test_dir, "output.txt")
    
    puts "\nğŸ“‹ Execution Details:"
    
    if File.exist?(output_file)
      puts "\n--- STDOUT ---"
      puts File.read(output_file).lines.last(10)
    end
    
    if File.exist?(error_file) && File.size(error_file) > 0
      puts "\n--- STDERR ---"
      puts File.read(error_file).lines.last(10)
    end
  end
end

# Main execution
if __FILE__ == $0
  begin
    tester = QuickTester.new
    success = tester.run_test
    
    if success
      puts "\nğŸ‰ Quick test PASSED! Refactoring appears to be working correctly."
      exit 0
    else
      puts "\nğŸ’¥ Quick test FAILED! Please review the refactoring changes."
      exit 1
    end
    
  rescue Interrupt
    puts "\nâŒ Quick test cancelled by user"
    exit 1
  rescue => e
    puts "\nâŒ Error running quick test: #{e.message}"
    puts "ğŸ› #{e.backtrace.join("\n   ")}" if ENV['DEBUG']
    exit 1
  end
end